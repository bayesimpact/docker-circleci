#!/usr/bin/env python3
"""A light implementation of Bazel parser."""

import collections
import functools
import glob
import hashlib
from importlib import abc, machinery, util
import logging
from os import path
import sys
from types import ModuleType
from typing import Any, ClassVar, Final, Iterable, Iterator, Literal, Optional, Union

# Allow importing modules from files with no extension, such as BUILD files.
machinery.SOURCE_SUFFIXES.append('')

_BUF_SIZE: Literal[65536] = 65536  # let's read stuff in 64kb chunks!


def _local_glob(pattern: str, folder: str) -> Iterator[str]:
    for file in glob.iglob(path.join(folder, pattern), recursive=True):
        if path.isfile(file):
            yield path.relpath(file, folder)


class RuleMeta(type):
    """A factory for target classes."""

    _all_rules: ClassVar[list['RuleMeta']] = []

    def __init__(cls, name: str, bases: tuple[type, ...], clsdict: dict[str, Any]) -> None:
        super().__init__(name, bases, clsdict)
        cls.rule_name = clsdict.get('rule_name', name)
        if clsdict.get('builtin', True):
            RuleMeta._all_rules.append(cls)

    @classmethod
    def set_rules(cls, module: ModuleType, package: 'Package') -> None:
        """Set all the rules as functions in the BUILD module of the package."""

        for rule in cls._all_rules:
            setattr(module, rule.rule_name, functools.partial(rule, package=package))


class _Rule(metaclass=RuleMeta):

    # TODO(cyrille): Implement the generic rule behavior here.
    rule_name = 'genrule'
    can_export_files = False

    def __init__(self, srcs: Iterable[Union[str, Iterator[str]]], package: 'Package') -> None:
        self._srcs: Final[list[File]] = [
            File(file, package, is_exported=self.can_export_files)
            for file_or_glob in srcs
            if (files := [file_or_glob] if isinstance(file_or_glob, str) else file_or_glob)
            for file in files]


class Target(_Rule):
    """A Bazel target."""

    def __init__(
            self, *, name: str, package: 'Package', deps: Optional[list[str]] = None,
            srcs: Optional[Iterable[Union[str, Iterator[str]]]] = None,
            visibility: Optional[Iterable[str]] = None, **unused_kwargs: Any) -> None:
        super().__init__(srcs=srcs or [], package=package)
        self.name: Final[str] = name
        self.package: Final['Package'] = package
        self.absolute_ref: Final[str] = package.absolute_ref if self.name == package.name else \
            f'{package.absolute_ref}:{self.name}'
        self.deps: set[Target] = set()
        self.downstream: set[Target] = {self}
        self._dependency_refs = set(deps or [])
        self._must_load_dependencies = True
        self._visibilities = package.default_visibility if visibility is None else {
            package.resolve_visibility(v) for v in visibility}
        if not package.get_target(f':{self.name}'):
            package.add_target(self)

    def _load_dependencies(self) -> None:
        if not self._must_load_dependencies:
            return
        self._must_load_dependencies = False
        for src in self._srcs:
            self.add_dependency(src)
        for dep in self._dependency_refs:
            if dep_target := self.package.get_target(dep):
                self.add_dependency(dep_target)
            else:
                self.package.wait_for(dep, self)

    def __str__(self) -> str:
        return self.absolute_ref

    def __hash__(self) -> int:
        return hash(self.absolute_ref)

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, self.__class__) and self.absolute_ref == other.absolute_ref

    def add_dependency(self, dep: 'Target') -> None:
        """Add a dependency to this rule. Also ensures this is possible."""

        if dep in self.deps:
            raise AssertionError(f'Cannot have two dependencies with the same ref: {dep}')
        if dep in self.downstream:
            raise AssertionError(f'Circular dependency between {self} and {dep}')
        if all(not v.can_show_to(self) for v in dep._visibilities):
            raise AssertionError(f'Dependency {dep} is not visible to {self}.')
        dep.downstream |= self.downstream
        self.deps.add(dep)

    @functools.cached_property
    def hash(self) -> str:  # pylint: disable=invalid-name
        """A hex-encoded hash of the content of this target."""

        hasher = hashlib.sha1(self.rule_name.encode())
        hasher.update(self.name.encode())
        self._load_dependencies()
        for dep in sorted(self.deps, key=lambda d: d.absolute_ref):
            hasher.update(dep.hash.encode())
        return hasher.hexdigest()


type('circle_job', (Target,), {})
type('container_image', (Target,), {})
type('filegroup', (Target,), {})
type('js_binary', (Target,), {})
type('proto_library', (Target,), {})
type('py_binary', (Target,), {})
type('py_library', (Target,), {})
type('py_test', (Target,), {})
type('sh_binary', (Target,), {})

type('exports_files', (_Rule,), {'can_export_files': True})


class File(Target):
    """Representation of a file as a target."""

    builtin = False

    def __init__(self, name: str, package: 'Package', *, is_exported: bool) -> None:
        super().__init__(name=name, package=package)
        self._must_load_dependencies = False
        self._visibilities = {Public() if is_exported else Private()}
        # Make sure the file exists.
        assert self.hash

    @functools.cached_property
    def hash(self) -> str:
        hasher = hashlib.sha1(super().hash.encode())
        with open(path.join(self.package.path, self.name), 'rb') as bytestream:
            while True:
                chunk = bytestream.read(_BUF_SIZE)
                if not chunk:
                    break
                hasher.update(chunk)
        return hasher.hexdigest()


class PackageRule(_Rule):

    rule_name = 'package'

    def __init__(
            self, *,
            package: 'Package', default_visibility: Optional[Iterable[str]] = None,
            **unused_kwargs: Any) -> None:
        super().__init__(srcs=[], package=package)
        if package._targets:
            raise AssertionError(
                f'The "{self.rule_name}" rule should be the first declared rule in the package.')
        if default_visibility is not None:
            package.default_visibility = {package.resolve_visibility(v) for v in default_visibility}


class PackageGroup(Target):

    rule_name = 'package_group'

    def __init__(
            self, *, package: 'Package', name: str,
            packages: Optional[Iterable[str]] = None) -> None:
        super().__init__(name=name, package=package)
        self.visibilities: list[Visibility] = []
        for pack in packages or []:
            if pack.startswith('-'):
                raise NotImplementedError('Cannot exclude packages from visibility for now.')
            if not pack.startswith('//'):
                raise AssertionError('Package group packages should start with "//".')
            if ':' in pack:
                raise AssertionError('Package group may only contains packages.')
            if pack.endswith('...'):
                pack = f'{pack.removesuffix("...")}:__subpackages__'
            else:
                pack = f'{pack}:__pkg__'
            self.visibilities.append(package.resolve_visibility(pack))


class Visibility:

    def can_show_to(self, unused_target: Target) -> bool:
        return False


class Public(Visibility):
    def can_show_to(self, unused_target: Target) -> bool:
        return True


class PackageVis(Visibility):
    def __init__(self, package: 'Package') -> None:
        self._package = package

    def can_show_to(self, target: Target) -> bool:
        return target.package == self._package


class SubpackageVis(Visibility):
    def __init__(self, package: 'Package') -> None:
        self._package = package

    def can_show_to(self, target: Target) -> bool:
        return self._package.is_parent_of(target.package)


class PackageGroupVis(Visibility):
    def __init__(self, group: PackageGroup) -> None:
        self._group = group

    def can_show_to(self, target: Target) -> bool:
        return any(v.can_show_to(target) for v in self._group.visibilities)


class Package:
    """Representation of a Bazel package."""

    def __init__(self, name: str, parent: 'Package') -> None:
        self.name: Final[str] = name
        self.path: Final[str] = self.dir if isinstance(self, Workspace) else path.join(parent.path, name)
        self.root: Final[Workspace] = self if isinstance(self, Workspace) else parent.root
        path_to_root = '' if isinstance(self, Workspace) else path.relpath(self.path, self.root.dir)
        self.absolute_ref: Final[str] = f'@{self.root.name}//{path_to_root}'
        self.default_visibility: set[Visibility] = {PackageVis(self)}
        self._must_load = True
        self._children: dict[str, 'Package'] = {}
        self._targets: dict[str, Target] = {}
        self._waiting_for_dep: dict[str, set[Target]] = collections.defaultdict(set)

    def __hash__(self) -> int:
        return hash(self.path)

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, self.__class__) and other.path == self.path

    def __str__(self) -> str:
        return self.absolute_ref

    def _load(self) -> None:
        """Load all the rules for this package."""

        if not self._must_load:
            return
        self._must_load = False
        build_file = path.join(self.path, 'BUILD')
        if not path.exists(build_file):
            logging.warning('No BUILD file found in "%s".', build_file)
            return
        logging.info('Building %s', self)
        build_spec = util.spec_from_file_location('BUILD', build_file)
        assert build_spec
        if not isinstance(build_spec.loader, abc.Loader):
            raise TypeError(f'Unable to load spec from file: {build_spec.__class__}')
        build_module = util.module_from_spec(build_spec)
        setattr(build_module, 'glob', functools.partial(_local_glob, folder=self.path))
        RuleMeta.set_rules(build_module, self)
        build_spec.loader.exec_module(build_module)

    def add_target(self, target: Target) -> None:
        """Add a target to the package, and resolve the missing dependency links."""

        if target.name in self._targets:
            raise ValueError(f'Cannot add a target twice: "{self.absolute_ref}:{target.name}"')
        self._targets[target.name] = target
        if target.name == self.name:
            self._targets[''] = target
        for waiter in self._waiting_for_dep[target.name]:
            waiter.add_dependency(target)
        del self._waiting_for_dep[target.name]

    def getpackage(self, rel_path: Union[str, list[str]]) -> 'Package':
        """Returns the package in the current workspace at the given relative path."""

        if not rel_path:
            return self
        if isinstance(rel_path, str):
            if rel_path.startswith('//'):
                return self.root.getpackage(rel_path.removeprefix('//'))
            rel_path = rel_path.split('/')
        child = self._children.get(rel_path[0])
        if not child:
            self._children[rel_path[0]] = child = Package(rel_path[0], self)
        return child.getpackage(rel_path[1:])

    @staticmethod
    def _split_target(name: str) -> tuple[str, str]:
        if ':' not in name:
            name = f'{name}:'
        package, name = name.split(':')
        return package, name

    def is_parent_of(self, other: 'Package') -> bool:
        """Whether other is a subpackage of self."""

        return other.absolute_ref.startswith(self.absolute_ref)

    def resolve_visibility(self, vis: str) -> Visibility:
        if vis == '//visibility:public':
            return Public()
        package, local_vis = self._split_target(vis)
        if package == '//visibility':
            if local_vis == 'public':
                return Public()
            if local_vis == 'private':
                return PackageVis(self)
            raise ValueError(f'Unrecognized global visibility "{local_vis}"')
        if package:
            return self.getpackage(package).resolve_visibility(f':{local_vis}')
        if local_vis == '__pkg__':
            return PackageVis(self)
        if local_vis == '__subpackages__':
            return SubpackageVis(self)
        self._load()
        package_group = self.get_target(f':{local_vis}')
        if not package_group:
            raise AssertionError(f'Visibility "{local_vis}" must be a defined target.')
        if isinstance(package_group, PackageGroup):
            return PackageGroupVis(package_group)
        raise AssertionError(f'Visibility "{self}:{local_vis}" must be a "package_group".')


    def get_target(self, name: str) -> Optional[Target]:
        """Find the target with the given reference, if it exists."""

        package, name = self._split_target(name)
        if package:
            return self.getpackage(package).get_target(f':{name}')
        self._load()
        return self._targets.get(name)

    def wait_for(self, reference: str, target: Target) -> None:
        """Keep a record of a dependency link with a not-yet-existing target.

        Once a target at the given reference is created,
        it must be added as a dependency to the given target.
        """

        package, name = self._split_target(reference)
        if package:
            self.getpackage(package).wait_for(name, target)
        else:
            self._waiting_for_dep[name].add(target)

    def get_all_targets(
            self, *,
            exclude: Optional[Iterable[RuleMeta]] = None,
            recursive: bool = False) -> Iterator[Target]:
        """List all targets inside this package.

        Possibly exclude given types of targets (File targets are excluded by default).
        Possibly list recursively.
        """

        self._load()
        if exclude is None:
            exclude = (File,)
        for name, target in self._targets.items():
            if name and target.__class__ not in exclude:
                yield target
        if not recursive:
            return
        for package in self._children.values():
            yield from package.get_all_targets(exclude=exclude, recursive=recursive)


class Workspace(Package):
    """A Bazel workspace.

    This is also a package, which is described with the root directory BUILD file.
    Constructor takes the root folder as parameter.
    """

    def __init__(self, root_dir: str) -> None:
        if not path.exists(path.join(root_dir, 'WORKSPACE')):
            raise AssertionError('The workspace is missing a WORKSPACE file at root.')
        self.dir: Final[str] = root_dir
        name = path.basename(path.abspath(root_dir))
        super().__init__(name, self)
        self._children['third_party'] = _ThirdParty(self)

    def resolve_all(self) -> Iterator[Target]:
        """Resolve all Bazel BUILD files in this workspace.

        This is useful when not all targets are dependencies of a target in the root package.
        """

        yield from self.get_all_targets()
        for file in _local_glob('*/**/BUILD', self.dir):
            package_ref = file.removesuffix('/BUILD')
            yield from self.getpackage(package_ref).get_all_targets()


class _ThirdParty(Package):

    def __init__(self, parent: Workspace) -> None:
        super().__init__('third_party', parent)
        self._must_load = False

    def add_target(self, unused_target: Target) -> None:
        # TODO(cyrille): Check 3rd party version somehow.
        pass

    def getpackage(self, unused_path: Union[str, list[str]]) -> Package:
        return self


if __name__ == '__main__':
    # TODO(cyrille): Use argparse to be able to do different things.
    print(Workspace(sys.argv[1]).get_target('.circleci').hash)
