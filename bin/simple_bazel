#!/usr/bin/env python3
"""A light implementation of Bazel parser."""

import collections
import functools
import glob
import hashlib
from importlib import abc, machinery, util
import logging
from os import path
import sys
from types import ModuleType
from typing import Any, ClassVar, Final, Iterable, Iterator, Literal, Optional, Union

# Allow importing modules from files with no extension, such as BUILD files.
machinery.SOURCE_SUFFIXES.append('')

_BUF_SIZE: Literal[65536] = 65536  # let's read stuff in 64kb chunks!


def _local_glob(pattern: str, folder: str) -> Iterator[str]:
    for file in glob.iglob(path.join(folder, pattern), recursive=True):
        if path.isfile(file):
            yield path.relpath(file, folder)


class RuleMeta(type):
    """A factory for target classes."""

    _all_rules: ClassVar[list['RuleMeta']] = []

    def __init__(cls, name: str, bases: tuple[type, ...], clsdict: dict[str, Any]) -> None:
        super().__init__(name, bases, clsdict)
        cls.rule_name = clsdict.get('rule_name', name)
        if clsdict.get('builtin', True):
            RuleMeta._all_rules.append(cls)

    @classmethod
    def set_rules(cls, module: ModuleType, package: 'Package') -> None:
        """Set all the rules as functions in the BUILD module of the package."""

        for rule in cls._all_rules:
            setattr(module, rule.rule_name, functools.partial(rule, package=package))


class _Rule(metaclass=RuleMeta):

    # TODO(cyrille): Implement the generic rule behavior here.
    rule_name = 'genrule'

    def __init__(self, srcs: Iterable[Union[str, Iterator[str]]], package: 'Package') -> None:
        self._srcs: Final[list[File]] = [
            File(file, package)
            for file_or_glob in srcs
            if (files := [file_or_glob] if isinstance(file_or_glob, str) else file_or_glob)
            for file in files]


class Target(_Rule):
    """A Bazel target."""

    def __init__(
            self, *, name: str, deps: Optional[list[str]] = None,
            srcs: Optional[Iterable[Union[str, Iterator[str]]]] = None,
            package: 'Package', **unused_kwargs: Any) -> None:
        super().__init__(srcs=srcs or [], package=package)
        self.name: Final[str] = name
        self._package: Final['Package'] = package
        self.absolute_ref: Final[str] = package.absolute_ref if self.name == package.name else \
            f'{package.absolute_ref}:{self.name}'
        self.deps: set[Target] = set()
        self.downstream: set[Target] = {self}
        self._dependency_refs = set(deps or [])
        self._must_load_dependencies = True
        if not package.get_target(f':{self.name}'):
            package.add_target(self)

    def _load_dependencies(self) -> None:
        if not self._must_load_dependencies:
            return
        self._must_load_dependencies = False
        for src in self._srcs:
            self.add_dependency(src)
        for dep in self._dependency_refs:
            if dep_target := self._package.get_target(dep):
                self.add_dependency(dep_target)
            else:
                self._package.wait_for(dep, self)

    def __str__(self) -> str:
        return self.absolute_ref

    def __hash__(self) -> int:
        return hash(self.absolute_ref)

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, self.__class__) and self.absolute_ref == other.absolute_ref

    def add_dependency(self, dep: 'Target') -> None:
        """Add a dependency to this rule. Also ensures this is possible."""

        if dep in self.deps:
            raise AssertionError(f'Cannot have two dependencies with the same ref: {dep}')
        if dep in self.downstream:
            raise AssertionError(f'Circular dependency between {self} and {dep}')
        dep.downstream |= self.downstream
        self.deps.add(dep)

    @functools.cached_property
    def hash(self) -> str:  # pylint: disable=invalid-name
        """A hex-encoded hash of the content of this target."""

        hasher = hashlib.sha1(self.rule_name.encode())
        hasher.update(self.name.encode())
        self._load_dependencies()
        for dep in sorted(self.deps, key=lambda d: d.absolute_ref):
            hasher.update(dep.hash.encode())
        return hasher.hexdigest()


type('circle_job', (Target,), {})
type('container_image', (Target,), {})
type('filegroup', (Target,), {})
type('js_binary', (Target,), {})
type('proto_library', (Target,), {})
type('py_binary', (Target,), {})
type('py_library', (Target,), {})
type('py_test', (Target,), {})
type('sh_binary', (Target,), {})

type('exports_files', (_Rule,), {})


class File(Target):
    """Representation of a file as a target."""

    builtin = False

    def __init__(self, name: str, package: 'Package') -> None:
        super().__init__(name=name, package=package)
        self._must_load_dependencies = False
        # Make sure the file exists.
        assert self.hash

    @functools.cached_property
    def hash(self) -> str:
        hasher = hashlib.sha1(super().hash.encode())
        with open(path.join(self._package.path, self.name), 'rb') as bytestream:
            while True:
                chunk = bytestream.read(_BUF_SIZE)
                if not chunk:
                    break
                hasher.update(chunk)
        return hasher.hexdigest()


class Package:
    """Representation of a Bazel package."""

    def __init__(self, name: str, parent: 'Package') -> None:
        self.name: Final[str] = name
        self.path: Final[str] = self.dir if isinstance(self, Workspace) else path.join(parent.path, name)
        self.root: Final[Workspace] = self if isinstance(self, Workspace) else parent.root
        path_to_root = '' if isinstance(self, Workspace) else path.relpath(self.path, self.root.dir)
        self.absolute_ref: Final[str] = f'@{self.root.name}//{path_to_root}'
        self._must_load = True
        self._children: dict[str, 'Package'] = {}
        self._targets: dict[str, Target] = {}
        self._waiting_for_dep: dict[str, set[Target]] = collections.defaultdict(set)

    def __hash__(self) -> int:
        return hash(self.path)

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, self.__class__) and other.path == self.path

    def __str__(self) -> str:
        return self.absolute_ref

    def _load(self) -> None:
        """Load all the rules for this package."""

        if not self._must_load:
            return
        self._must_load = False
        build_file = path.join(self.path, 'BUILD')
        if not path.exists(build_file):
            logging.warning('No BUILD file found in "%s".', build_file)
            return
        logging.info('Building %s', self)
        build_spec = util.spec_from_file_location('BUILD', build_file)
        assert build_spec
        if not isinstance(build_spec.loader, abc.Loader):
            raise TypeError(f'Unable to load spec from file: {build_spec.__class__}')
        build_module = util.module_from_spec(build_spec)
        setattr(build_module, 'glob', functools.partial(_local_glob, folder=self.path))
        RuleMeta.set_rules(build_module, self)
        build_spec.loader.exec_module(build_module)

    def add_target(self, target: Target) -> None:
        """Add a target to the package, and resolve the missing dependency links."""

        if target.name in self._targets:
            raise ValueError(f'Cannot add a target twice: "{self.absolute_ref}:{target.name}"')
        self._targets[target.name] = target
        if target.name == self.name:
            self._targets[''] = target
        for waiter in self._waiting_for_dep[target.name]:
            waiter.add_dependency(target)
        del self._waiting_for_dep[target.name]

    def get_package(self, rel_path: Union[str, list[str]]) -> 'Package':
        """Returns the package in the current workspace at the given relative path."""

        if not rel_path:
            return self
        if isinstance(rel_path, str):
            if rel_path.startswith('//'):
                return self.root.get_package(rel_path.removeprefix('//'))
            rel_path = rel_path.split('/')
        child = self._children.get(rel_path[0])
        if not child:
            self._children[rel_path[0]] = child = Package(rel_path[0], self)
        return child.get_package(rel_path[1:])

    @staticmethod
    def _split_target(name: str) -> tuple[str, str]:
        if ':' not in name:
            name = f'{name}:'
        package, name = name.split(':')
        return package, name

    def get_target(self, name: str) -> Optional[Target]:
        """Find the target with the given reference, if it exists."""

        package, name = self._split_target(name)
        if package:
            return self.get_package(package).get_target(f':{name}')
        self._load()
        return self._targets.get(name)

    def wait_for(self, reference: str, target: Target) -> None:
        """Keep a record of a dependency link with a not-yet-existing target.

        Once a target at the given reference is created,
        it must be added as a dependency to the given target.
        """

        package, name = self._split_target(reference)
        if package:
            self.get_package(package).wait_for(name, target)
        else:
            self._waiting_for_dep[name].add(target)

    def get_all_targets(
            self, *,
            exclude: Optional[Iterable[RuleMeta]] = None,
            recursive: bool = False) -> Iterator[Target]:
        """List all targets inside this package.

        Possibly exclude given types of targets (File targets are excluded by default).
        Possibly list recursively.
        """

        self._load()
        if exclude is None:
            exclude = (File,)
        for name, target in self._targets.items():
            if name and target.__class__ not in exclude:
                yield target
        if not recursive:
            return
        for package in self._children.values():
            yield from package.get_all_targets(exclude=exclude, recursive=recursive)


class Workspace(Package):
    """A Bazel workspace.

    This is also a package, which is described with the root directory BUILD file.
    Constructor takes the root folder as parameter.
    """

    def __init__(self, root_dir: str) -> None:
        if not path.exists(path.join(root_dir, 'WORKSPACE')):
            raise AssertionError('The workspace is missing a WORKSPACE file at root.')
        self.dir: Final[str] = root_dir
        name = path.basename(path.abspath(root_dir))
        super().__init__(name, self)
        self._children['third_party'] = _ThirdParty(self)

    def resolve_all(self) -> Iterator[Target]:
        """Resolve all Bazel BUILD files in this workspace.

        This is useful when not all targets are dependencies of a target in the root package.
        """

        yield from self.get_all_targets()
        for file in _local_glob('*/**/BUILD', self.dir):
            package_ref = file.removesuffix('/BUILD')
            yield from self.get_package(package_ref).get_all_targets()


class _ThirdParty(Package):

    def __init__(self, parent: Workspace) -> None:
        super().__init__('third_party', parent)
        self._must_load = False

    def add_target(self, unused_target: Target) -> None:
        # TODO(cyrille): Check 3rd party version somehow.
        pass

    def get_package(self, unused_path: Union[str, list[str]]) -> Package:
        return self


if __name__ == '__main__':
    # TODO(cyrille): Use argparse to be able to do different things.
    print(Workspace(sys.argv[1]).get_target('.circleci').hash)
