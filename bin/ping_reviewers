#!/usr/bin/env python3
"""Ping reviewers for a given branch.

Assumes a CIRCLE CI context, with the following additional environment:
- SLACK_INTEGRATION_URL: a slack webhook URL
- GITHUB_TOKEN: a Github token with read access on Pull Requests
- SLACK_GITHUB_USER_PAIRINGS: a JSON representation of a dict with Github user handles as keys
    and corresponding Slack user IDs as values.
Those are available in bayesimpact org under the Slack context.
"""

import argparse
import datetime
import json
import logging
import os
import typing
from typing import Any, Literal, Generic, NamedTuple, Optional, Protocol, TypedDict, Union

import requests


class _Config(NamedTuple):
    # The full name of the changed github repository. Fetched from CircleCI environment.
    github_repo: str

    # A pairing between github user logins and Slack user IDs.
    # Fetched from CircleCI 'Slack' context.
    github_to_slack: dict[str, str]

    # A token to access Github API with read rights on PR info.
    # Fetched from CircleCI 'Slack' context.
    github_token: str

    # The number of the current PR. Fetched from CircleCI environment
    pr_number: str

    # A webhook URL for slack. Fetched from CircleCI 'Slack' context.
    slack_url: str

    @staticmethod
    def from_env(environ: Optional[dict[str, str]] = None) -> '_Config':
        """Generate from an environment dict."""

        env = environ or dict(os.environ)
        slack_url = env.get('SLACK_INTEGRATION_URL', '')
        github_token = env.get('GITHUB_TOKEN', '')

        github_repo = '/'.join((
            env.get('CIRCLE_PROJECT_USERNAME', ''), env.get('CIRCLE_PROJECT_REPONAME', '')))
        pr_number = env.get('CIRCLE_PULL_REQUEST', '').rsplit('/', 1)[-1]

        github_to_slack: dict[str, str] = json.loads(env.get('SLACK_GITHUB_USER_PAIRINGS', r'{}'))
        return _Config(github_repo, github_to_slack, github_token, pr_number, slack_url)


class _GithubUser(TypedDict):
    """A user object."""

    login: str


class _GithubRepo(TypedDict):
    """A repository object."""

    default_branch: str
    full_name: str
    owner: _GithubUser


class _GithubPullRequestBase(TypedDict, total=False):
    """The base commit of a Pull Request."""

    repo: _GithubRepo


class _GithubCommit(TypedDict):
    """A commit objet."""

    message: str
    ref: str
    sha: str


class _GithubPullRequest(TypedDict, total=False):
    """A pull-request object."""

    author: _GithubUser
    base: _GithubPullRequestBase
    created_at: str
    node_id: str
    head: _GithubCommit
    number: int
    requested_reviewers: list[_GithubUser]
    assignees: list[_GithubUser]
    user: _GithubUser
    title: str


_T = typing.TypeVar('_T')


class _Connection(Protocol, Generic[_T]):
    def __getitem__(self, nodes: Literal['nodes']) -> list[_T]:
        pass

    def get(self, nodes: Literal['nodes'], default: list[_T]) -> list[_T]:
        pass


_PULL_REQUEST_INFO_GRAPHQL_QUERY = '''query($prNodeId: ID!) {
    node(id:$prNodeId) {
        ... on PullRequest {
            commits(last:1) {
                nodes {
                    commit {
                        statusCheckRollup {
                            contexts(last:100) {
                                nodes {
                                    ... on StatusContext{
                                        context
                                        targetUrl
                                    }
                                }
                            }
                            state
                        }
                    }
                }
            }
        }
    }
}'''
_Context = TypedDict('_Context', {'context': str, 'targetUrl': str}, total=False)
_StatusState = Literal['ERROR', 'EXPECTED', 'FAILURE', 'PENDING', 'SUCCESS']
_Rollup = TypedDict('_Rollup', {
    'contexts': _Connection[_Context],
    'state': _StatusState,
}, total=False)
_Commit = TypedDict('_Commit', {'statusCheckRollup': _Rollup}, total=False)
_PRCommit = TypedDict('_PRCommit', {'commit': _Commit})
_PullRequest = TypedDict('_PullRequest', {'commits': _Connection[_PRCommit]})
_Node = TypedDict('_Node', {'node': _PullRequest}, total=False)
_Response = TypedDict('_Response', {'data': _Node})


class _Request(TypedDict, total=False):
    text: str
    channel: str
    attachments: list[dict[str, Any]]


def _get_user(github_handle: str, config: _Config, as_channel: bool = False) -> str:
    try:
        user_id = config.github_to_slack[github_handle]
    except KeyError:
        if as_channel:
            raise
        # Use handle as username, for human-readability.
        return f'@{github_handle}'
    return f'@{user_id}' if as_channel else f'<@{user_id}>'


# TODO(cyrille): Consider using a repo-specific channel.
def _post_to_slack(prepared_request: _Request, config: _Config) -> None:
    response = requests.post(config.slack_url, json=prepared_request)
    response.raise_for_status()


def _send_review(
        number: str, title: str, github_author: str, demo_url: Optional[str], config: _Config, *,
        github_reviewer: Optional[str] = None, reviewers: Optional[str] = None) -> None:
    from_author = f"{_get_user(github_author, config)}'s"
    request: _Request = {
        'text': (f'A <{demo_url}|demo> is ready' if demo_url else 'CI tests passed') +
        f' for {from_author} PR <https://reviewable.io/reviews'
        f'/{config.github_repo}/{number}|#{number}>.',
        'attachments': [{'text': title}],
    }
    if github_reviewer:
        request['channel'] = _get_user(github_reviewer, config, as_channel=True)
        request['text'] += ' You can start looking at it.'
    elif reviewers:
        request['text'] += f' Reviewers ({reviewers}) can start looking at it.'
    _post_to_slack(request, config)


def _check_deeper(pull_request: _GithubPullRequest, config: _Config) -> Union[bool, str]:
    """Whether the given commit needs a review, and if so on what demo."""

    response = requests.get('https://api.github.com/graphql', data={
        'query': _PULL_REQUEST_INFO_GRAPHQL_QUERY,
        'variables': {'prNodeId': pull_request['node_id']},
    }, headers={'Authorization': f'token {config.github_token}'})
    response.raise_for_status()
    graphql_response: _Response = response.json()
    pr_data = graphql_response.get('data', {}).get('node')
    if not pr_data:
        # Unable to fetch PR data somehow, let's assume it needs reviewing.
        return True
    commits = pr_data.get('commits', {}).get('nodes', [])
    if not commits:
        # Couldn't find any commit to merge in this PR, it probably doesn't need any reviewing.
        return False
    rollup = commits[0].get('commit', {}).get('statusCheckRollup', {})
    if rollup.get('state') != 'PENDING':
        # Global state is either ERROR or SUCCESS. In both cases, no need to ask for review.
        return False
    demo_url = next((
        status.get('targetUrl')
        for status in rollup.get('contexts', {}).get('nodes', [])
        if status.get('context') == 'bayesimpact/demo-frontend'), None)
    return demo_url or True


def ping_request_reviewers(
        pull_request: _GithubPullRequest, demo_url: Optional[str], config: _Config, *,
        before: Optional[datetime.datetime] = None, should_check: bool = False) -> int:
    """Ping reviewers for a given PR."""

    if before and before < datetime.datetime.fromisoformat(
            pull_request['created_at'].removesuffix('Z')):
        return 0
    if pull_request.get('author', {}).get('login', '').endswidth('[bot]'):
        # Not pinging for bot reviews.
        return 0
    if should_check:
        # Make sure we actually want a review.
        demo_url_or_bool = _check_deeper(pull_request, config)
        if not demo_url_or_bool:
            return 0
        if not demo_url and isinstance(demo_url_or_bool, str):
            demo_url = demo_url_or_bool
    all_reviewers = list(filter(None, {
        reviewer.get('login', '')
        for reviewer_list in (
            pull_request.get('requested_reviewers', []),
            pull_request.get('assignees', []))
        for reviewer in reviewer_list}))
    if not all_reviewers:
        return 0
    pr_number = str(pull_request['number'])
    logging.info(
        'Pinging reviewers (of #%s) on Slack to tell them the Demo is readyâ€¦', pr_number)
    title = pull_request['title']
    author = pull_request['user']['login']
    ping_count = 0
    try:
        for reviewer in all_reviewers:
            # TODO(cyrille): Only ping the reviewers who haven't LGTM.
            # TODO(cyrille): Ping the author if there are no reviewers without LGTM.
            _send_review(pr_number, title, author, demo_url, config, github_reviewer=reviewer)
            ping_count += 1
    except (requests.HTTPError, KeyError):
        # Unable to send the review to one of the reviewers, sending it to default channel.
        named_reviewers = ', '.join(_get_user(r, config) for r in sorted(all_reviewers))
        _send_review(pr_number, title, author, demo_url, config, reviewers=named_reviewers)
        ping_count += 1
    return ping_count


def ping_reviewers(demo_url: Optional[str], ping_stale_reviews: bool, config: _Config) -> int:
    """Send slack pings to the relevant people, if requirements are met."""

    if not config.slack_url:
        logging.info('Slack integration URL is missing, please set SLACK_INTEGRATION_URL')
        return 0
    if not config.github_token:
        logging.info('Need a Github token to get PR info, please set GITHUB_TOKEN')
        return 0
    if config.github_repo.strip('/') != config.github_repo:
        logging.info(
            'No Github repo specified, '
            'please set CIRCLE_PROJECT_USERNAME and CIRCLE_PROJECT_REPONAME')
        return 0
    # TODO(cyrille): Consider fetching the available PRs from Github if pr_number is empty.
    if not config.pr_number and not ping_stale_reviews:
        logging.info('No PR to review, please set CIRCLE_PULL_REQUEST with a Github PR url')
        return 0
    query = f'https://api.github.com/repos/{config.github_repo}/pulls/{config.pr_number}'
    if ping_stale_reviews:
        query = f'https://api.github.com/repos/{config.github_repo}/pulls?direction=asc'
    response = requests.get(query, headers={
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': f'token {config.github_token}',
    })
    response.raise_for_status()
    pull_requests = response.json()
    if not ping_stale_reviews:
        # Response to the /pulls/PR_NUMBER endpoint only has 1 PR in its answer.
        pull_requests = [pull_requests]
    yesterday = datetime.datetime.now() - datetime.timedelta(days=1)
    ping_count = 0
    for pull_request in pull_requests:
        ping_count += ping_request_reviewers(
            pull_request, demo_url, config, before=yesterday if ping_stale_reviews else None)
    return ping_count


def main(string_args: Optional[list[str]] = None, env: Optional[dict[str, str]] = None) -> int:
    """Parse CLI arguments and ping reviewers.

    Return the number of ping sent (for testing purposes).
    # TODO(cyrille): Test differently and stop returning the number of pings.
    """

    parser = argparse.ArgumentParser(description='Ping reviewers for the current PR.')
    parser.add_argument(
        'demo_url', help='A URL where a demo for the changes can be found.', nargs='?')
    parser.add_argument('--ping-stale-reviews', action='store_true')
    args = parser.parse_args(string_args)
    return ping_reviewers(args.demo_url, args.ping_stale_reviews, _Config.from_env(env))


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
