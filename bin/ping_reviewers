#!/usr/bin/env python3
"""Ping reviewers for a given branch.

Assumes a CIRCLE CI context, with the following additional environment:
- SLACK_INTEGRATION_URL: a slack webhook URL
- GITHUB_TOKEN: a Github token with read access on Pull Requests
- SLACK_GITHUB_USER_PAIRINGS: a JSON representation of a dict with Github user handles as keys
    and corresponding Slack user IDs as values.
Those are available in bayesimpact org under the Slack context.
"""

import argparse
import datetime
import json
import logging
import os
from typing import Any, Optional, TypedDict

import requests

_SLACK_INTEGRATION_URL = os.getenv('SLACK_INTEGRATION_URL', '')
_GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')

_REPO = f"{os.getenv('CIRCLE_PROJECT_USERNAME', '')}/{os.getenv('CIRCLE_PROJECT_REPONAME', '')}"
_PR_NUMBER = os.getenv('CIRCLE_PULL_REQUEST', '').rsplit('/', 1)[-1]

_GITHUB_TO_SLACK: dict[str, str] = json.loads(os.getenv('SLACK_GITHUB_USER_PAIRINGS', r'{}'))


class _GithubUser(TypedDict):
    """A user object."""

    login: str


class _GithubRepo(TypedDict):
    """A repository object."""

    default_branch: str
    full_name: str
    owner: _GithubUser


class _GithubPullRequestBase(TypedDict, total=False):
    """The base commit of a Pull Request."""

    repo: _GithubRepo


class _GithubCommit(TypedDict):
    """A commit objet."""

    message: str
    ref: str
    sha: str


class _GithubPullRequest(TypedDict, total=False):
    """A pull-request object."""

    author: _GithubUser
    base: _GithubPullRequestBase
    created_at: str
    number: int
    requested_reviewers: list[_GithubUser]
    user: _GithubUser
    title: str


class _Request(TypedDict, total=False):
    text: str
    channel: str
    attachments: list[dict[str, Any]]


def _get_user(github_handle: str, as_channel: bool = False) -> str:
    try:
        user_id = _GITHUB_TO_SLACK[github_handle]
    except KeyError:
        if as_channel:
            raise
        # Use handle as username, for human-readability.
        return f'@{github_handle}'
    return f'@{user_id}' if as_channel else f'<@{user_id}>'


# TODO(cyrille): Consider using a repo-specific channel.
def _post_to_slack(prepared_request: _Request) -> None:
    response = requests.post(_SLACK_INTEGRATION_URL, json=prepared_request)
    response.raise_for_status()


def _send_review(
        title: str, github_author: str, demo_url: Optional[str], *,
        github_reviewer: Optional[str] = None, reviewers: Optional[str] = None) -> None:
    from_author = f"{_get_user(github_author)}'s"
    request: _Request = {
        'text': (f'A <{demo_url}|demo> is ready' if demo_url else 'CI tests passed') +
        f' for {from_author} PR '
        f'<https://reviewable.io/reviews/{_REPO}/{_PR_NUMBER}|#{_PR_NUMBER}>.',
        'attachments': [{'text': title}],
    }
    if github_reviewer:
        request['channel'] = _get_user(github_reviewer, as_channel=True)
        request['text'] += ' You can start looking at it.'
    elif reviewers:
        request['text'] += f' Reviewers ({reviewers}) can start looking at it.'
    _post_to_slack(request)


def ping_request_reviewers(
        pull_request: _GithubPullRequest, demo_url: Optional[str], *,
        before: Optional[datetime.datetime] = None) -> None:
    """Ping reviewers for a given PR."""

    if before and before < datetime.datetime.fromisoformat(
            pull_request['created_at'].removesuffix('Z')):
        return
    all_reviewers = list(filter(None, {
        reviewer.get('login', '')
        for reviewer_list in (
            pull_request.get('requested_reviewers', []),
            pull_request.get('assignees', []))
        for reviewer in reviewer_list}))
    if not all_reviewers:
        return
    logging.info('Pinging reviewers (of #%s) on Slack to tell them the Demo is readyâ€¦', _PR_NUMBER)
    title = pull_request['title']
    author = pull_request['user']['login']
    try:
        for reviewer in all_reviewers:
            # TODO(cyrille): Only ping the reviewers who haven't LGTM.
            # TODO(cyrille): Ping the author if there are no reviewers without LGTM.
            _send_review(title, author, demo_url, github_reviewer=reviewer)
    except (requests.HTTPError, KeyError):
        # Unable to send the review to one of the reviewers, sending it to default channel.
        named_reviewers = ', '.join(_get_user(r) for r in sorted(all_reviewers))
        _send_review(title, author, demo_url, reviewers=named_reviewers)


def ping_reviewers(demo_url: Optional[str], ping_stale_reviews: bool) -> None:
    """Send slack pings to the relevant people, if requirements are met."""

    if not _SLACK_INTEGRATION_URL:
        logging.info('Slack integration URL is missing, please set SLACK_INTEGRATION_URL')
        return
    if not _GITHUB_TOKEN:
        logging.info('Need a Github token to get PR info, please set GITHUB_TOKEN')
        return
    if _REPO.strip('/') != _REPO:
        logging.info(
            'No Github repo specified, '
            'please set CIRCLE_PROJECT_USERNAME and CIRCLE_PROJECT_REPONAME')
        return
    # TODO(cyrille): Consider fetching the available PRs from Github if _PR_NUMBER is empty.
    if not _PR_NUMBER and not ping_stale_reviews:
        logging.info('No PR to review, please set CIRCLE_PULL_REQUEST with a Github PR url')
        return
    query = f'https://api.github.com/repos/{_REPO}/pulls/{_PR_NUMBER}'
    if ping_stale_reviews:
        query = f'https://api.github.com/repos/{_REPO}/pulls?direction=asc'
    response = requests.get(query, headers={
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': f'token {_GITHUB_TOKEN}',
    })
    response.raise_for_status()
    pull_requests = response.json()
    if not ping_stale_reviews:
        # Response to the /pulls/PR_NUMBER endpoint only has 1 PR in its answer.
        pull_requests = [pull_requests]
    yesterday = datetime.datetime.now() - datetime.timedelta(days=1)
    for pull_request in pull_requests:
        ping_request_reviewers(
            pull_request, demo_url, before=yesterday if ping_stale_reviews else None)


def main(string_args: Optional[list[str]] = None):
    """Parse CLI arguments and ping reviewers."""

    parser = argparse.ArgumentParser(description='Ping reviewers for the current PR.')
    parser.add_argument(
        'demo_url', help='A URL where a demo for the changes can be found.', nargs='?')
    parser.add_argument('--ping-stale-reviews', action='store_true')
    args = parser.parse_args(string_args)
    ping_reviewers(args.demo_url, args.ping_stale_reviews)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
